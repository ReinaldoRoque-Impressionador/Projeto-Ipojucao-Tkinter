CRIANDO BOTÃƒO TESTAR DEPENDÃŠNCIAS:

import tkinter as tk
from tkinter import messagebox

def testar_dependencias():
    pacotes = {
        "matplotlib": "ImportaÃ§Ã£o grÃ¡fica",
        "pandas": "Planilhas e tabelas",
        "PIL": "ManipulaÃ§Ã£o de imagens",
        "tkcalendar": "CalendÃ¡rio no tkinter"
    }

    erros = []

    for modulo in pacotes:
        try:
            __import__(modulo)
        except ImportError:
            erros.append(f"âŒ {modulo} ({pacotes[modulo]})")

    if not erros:
        messagebox.showinfo("Testar DependÃªncias", "âœ… Todos os mÃ³dulos necessÃ¡rios estÃ£o instalados!")
    else:
        msg = "Algumas dependÃªncias estÃ£o faltando:\n\n" + "\n".join(erros)
        messagebox.showwarning("DependÃªncias ausentes", msg)



























Reinaldo, agora sim vamos criar um verdadeiro **Painel de DiagnÃ³stico Profissional** pro seu sistema â€” com testes automÃ¡ticos de mÃ³dulos, sugestÃµes de instalaÃ§Ã£o via `pip`, e um botÃ£o para exportar um log dos testes. Isso vai facilitar muito a manutenÃ§Ã£o e vai te poupar dor de cabeÃ§a no futuro ğŸ’¡ğŸ§°ğŸ“¦

---

## âœ… O que esse painel vai fazer:

1. Testar se os principais pacotes estÃ£o instalados (`matplotlib`, `pandas`, `PIL`, etc.)
2. Exibir um painel de status visual (em cores)
3. Sugerir o comando `pip install` para os pacotes ausentes
4. Permitir exportar o log como `.txt` com o resultado dos testes

---

## ğŸ§  Como usar

VocÃª pode colocar isso dentro da sua aba de configuraÃ§Ã£o (ex: `aba_config.py`) ou atÃ© numa aba separada chamada "DiagnÃ³stico".

---

## ğŸ§± CÃ³digo completo do painel

```python
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime

def criar_painel_diagnostico(parent):
    frame_diag = ttk.LabelFrame(parent, text="Painel de DiagnÃ³stico do Sistema")
    frame_diag.grid(row=99, column=0, padx=10, pady=10, sticky="nsew")

    text_output = tk.Text(frame_diag, width=80, height=15, state="disabled", bg="#f0f0f0")
    text_output.grid(row=1, column=0, padx=10, pady=5)

    def verificar_modulos():
        pacotes = {
            "matplotlib": "VisualizaÃ§Ã£o de grÃ¡ficos",
            "pandas": "ManipulaÃ§Ã£o de dados",
            "PIL": "Imagens (via Pillow)",
            "tkcalendar": "CalendÃ¡rio no Tkinter",
            "openpyxl": "Excel exportaÃ§Ã£o",
            "sqlite3": "Banco de dados local",
            "tkinter": "Interface grÃ¡fica",
        }

        text_output.configure(state="normal")
        text_output.delete("1.0", tk.END)
        text_output.insert(tk.END, f"ğŸ” Verificando dependÃªncias - {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n\n")

        ausentes = []

        for pacote in pacotes:
            try:
                if pacote == "PIL":
                    import PIL
                else:
                    __import__(pacote)
                text_output.insert(tk.END, f"âœ… {pacote} - OK ({pacotes[pacote]})\n")
            except ImportError:
                text_output.insert(tk.END, f"âŒ {pacote} - AUSENTE! ({pacotes[pacote]})\n")
                ausentes.append(pacote)

        if not ausentes:
            text_output.insert(tk.END, "\nâœ… Todos os pacotes estÃ£o instalados!\n")
        else:
            text_output.insert(tk.END, "\nâš ï¸ Pacotes ausentes:\n")
            for pacote in ausentes:
                text_output.insert(tk.END, f"   ğŸ‘‰ pip install {pacote}\n")

        text_output.configure(state="disabled")

    def exportar_log():
        conteudo = text_output.get("1.0", tk.END)
        if not conteudo.strip():
            messagebox.showwarning("ExportaÃ§Ã£o", "Nenhum conteÃºdo para exportar.")
            return

        caminho = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Arquivo de Texto", "*.txt")])
        if caminho:
            with open(caminho, "w", encoding="utf-8") as arquivo:
                arquivo.write(conteudo)
            messagebox.showinfo("ExportaÃ§Ã£o", f"Log exportado para:\n{caminho}")

    btn_testar = ttk.Button(frame_diag, text="ğŸ”„ Testar DependÃªncias", command=verificar_modulos)
    btn_testar.grid(row=0, column=0, pady=5, sticky="w")

    btn_exportar = ttk.Button(frame_diag, text="ğŸ’¾ Exportar Log", command=exportar_log)
    btn_exportar.grid(row=0, column=0, pady=5, sticky="e")

    return frame_diag
```

---

### ğŸ’¡ Como adicionar ao projeto:

No final de `montar_aba_config()` ou em `montar_aba_diagnostico()`:

```python
criar_painel_diagnostico(inner_frame)
```

---

Se quiser, posso ainda:

âœ… Integrar esse painel com um atalho no menu  
âœ… Criar um â€œAutoCorrigirâ€ que abre o terminal para instalar os pacotes (com cuidado)  
âœ… Exibir o ambiente Python ativo na tela

Quer que eu transforme esse painel em uma aba separada chamada "DiagnÃ³stico do Sistema" com log, versÃ£o do Python e sugestÃµes em tempo real? ğŸ˜„ğŸ”§ğŸ“‹ Vamos deixar esse projeto afiado!













Perfeito, Reinaldo! Vamos levar esse painel de diagnÃ³stico a um novo nÃ­vel. Aqui estÃ¡ o que ele vai ter:

---

### âœ… Funcionalidades do novo Painel de DiagnÃ³stico

| Recurso                       | O que faz                                                                 |
|------------------------------|---------------------------------------------------------------------------|
| **Testar DependÃªncias**      | Verifica se os pacotes essenciais estÃ£o instalados                        |
| **AutoCorrigir**             | Sugere e executa os comandos `pip install` diretamente do Python          |
| **Exportar Log**             | Salva os resultados da verificaÃ§Ã£o em um `.txt`                           |
| **Atalho no Menu Superior**  | Adiciona uma opÃ§Ã£o â€œDiagnÃ³stico do Sistemaâ€ para abrir o painel rapidamente |

---

### ğŸ§  Como funciona o AutoCorrigir

Ele verifica quais pacotes estÃ£o ausentes e executa dinamicamente:

```python
subprocess.check_call([sys.executable, "-m", "pip", "install", pacote])
```

Com isso, vocÃª instala diretamente os pacotes que faltam sem sair da interface!

---

### ğŸ§± CÃ³digo completo com integraÃ§Ã£o de AutoCorrigir + Menu

```python
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime
import sys
import subprocess

def criar_menu_diagnostico(janela_principal, notebook):
    menubar = tk.Menu(janela_principal)
    janela_principal.config(menu=menubar)

    menu_ferramentas = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Ferramentas", menu=menu_ferramentas)

    def abrir_aba_diagnostico():
        aba_diag = ttk.Frame(notebook)
        notebook.add(aba_diag, text="DiagnÃ³stico")
        montar_painel_diagnostico(aba_diag)
        notebook.select(aba_diag)

    menu_ferramentas.add_command(label="DiagnÃ³stico do Sistema ğŸ©º", command=abrir_aba_diagnostico)

def montar_painel_diagnostico(parent):
    frame_diag = ttk.LabelFrame(parent, text="ğŸ”§ DiagnÃ³stico do Sistema")
    frame_diag.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

    text_output = tk.Text(frame_diag, width=80, height=20, state="disabled", bg="#f0f0f0")
    text_output.grid(row=1, column=0, columnspan=3, padx=10, pady=5)

    pacotes = {
        "matplotlib": "VisualizaÃ§Ã£o de grÃ¡ficos",
        "pandas": "Planilhas e tabelas",
        "PIL": "ManipulaÃ§Ã£o de imagens (Pillow)",
        "tkcalendar": "CalendÃ¡rio em tkinter",
        "openpyxl": "Planilhas Excel",
        "sqlite3": "Banco de dados interno"
    }

    pacotes_faltando = []

    def testar():
        nonlocal pacotes_faltando
        pacotes_faltando = []

        text_output.configure(state="normal")
        text_output.delete("1.0", tk.END)
        text_output.insert(tk.END, f"VerificaÃ§Ã£o - {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n\n")

        for nome in pacotes:
            try:
                if nome == "PIL":
                    import PIL
                else:
                    __import__(nome)
                text_output.insert(tk.END, f"âœ… {nome} - OK ({pacotes[nome]})\n")
            except ImportError:
                text_output.insert(tk.END, f"âŒ {nome} - NÃƒO INSTALADO! ({pacotes[nome]})\n")
                pacotes_faltando.append(nome)

        if pacotes_faltando:
            text_output.insert(tk.END, "\nğŸ“¦ Para instalar manualmente:\n")
            for nome in pacotes_faltando:
                text_output.insert(tk.END, f"   pip install {nome}\n")
        else:
            text_output.insert(tk.END, "\nâœ… Tudo pronto, sem pendÃªncias!\n")

        text_output.configure(state="disabled")

    def corrigir_automaticamente():
        if not pacotes_faltando:
            messagebox.showinfo("AutoCorrigir", "Tudo jÃ¡ estÃ¡ instalado!")
            return

        for nome in pacotes_faltando:
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", nome])
                messagebox.showinfo("AutoCorrigir", f"{nome} instalado com sucesso.")
            except Exception as e:
                messagebox.showerror("Erro na instalaÃ§Ã£o", f"Falha ao instalar {nome}:\n{e}")

        testar()  # reexecutar apÃ³s instalar

    def exportar_log():
        log = text_output.get("1.0", tk.END)
        if not log.strip():
            messagebox.showwarning("ExportaÃ§Ã£o", "Sem conteÃºdo para exportar.")
            return
        caminho = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Arquivo de Texto", "*.txt")])
        if caminho:
            with open(caminho, "w", encoding="utf-8") as f:
                f.write(log)
            messagebox.showinfo("Exportado", f"Log salvo em:\n{caminho}")

    ttk.Button(frame_diag, text="ğŸ” Testar", command=testar).grid(row=0, column=0, padx=10, pady=5)
    ttk.Button(frame_diag, text="ğŸ›  AutoCorrigir", command=corrigir_automaticamente).grid(row=0, column=1, padx=10, pady=5)
    ttk.Button(frame_diag, text="ğŸ’¾ Exportar Log", command=exportar_log).grid(row=0, column=2, padx=10, pady=5)
```

---

### ğŸ’¡ Como ativar no `main.py`

Adicione no final do seu `main.py`, apÃ³s construir a janela e o notebook:

```python
from aba_diagnostico import criar_menu_diagnostico  # se vocÃª salvar isso num novo arquivo

criar_menu_diagnostico(janela, notebook)
```

Ou, se estiver junto da `aba_config`, chame direto no final do `montar_aba_config()`.

---

Pronto, agora vocÃª tem um painel de diagnÃ³stico de verdade!  
Quer que eu transforme isso numa aba com grÃ¡fico de status tambÃ©m? ğŸ˜„ğŸ“¦ğŸ“ˆ Podemos atÃ© mostrar a porcentagem de pacotes instalados com uma barra de progresso. SÃ³ avisar que seguimos turbinando!



















import tkinter as tk
from tkinter import ttk, Entry, BooleanVar
from PIL import Image, ImageTk
import os
from tkcalendar import DateEntry
import sqlite3
import time
import dados_compartilhados as dc
#from aba_consulta import montar_aba_consulta
import pandas as pd
#import matplotlib.pyplot as plt
#from models import database, criar_app
from aba_diagnostico import criar_menu_diagnostico

#root = tk.Tk()

# #+++++++++++++++++++++++++++++++++++++++++++


import tkinter as tk
from tkinter import ttk
import dados_compartilhados as dc

# ğŸªŸ Criando janela principal
janela = tk.Tk()
janela.title("Planilha Controle IpojucÃ£o")
janela.geometry("1024x700")
janela.rowconfigure(0, weight=1)
janela.columnconfigure(0, weight=1)

# ğŸ“’ Criando o Notebook (abas)
notebook = ttk.Notebook(janela)
notebook.grid(row=0, column=0, sticky="nsew")

# ğŸ§  Inicializando variÃ¡veis globais (exemplo mÃ­nimo)
dc.var_porte = tk.StringVar(value="pequeno")
dc.var_raca = tk.StringVar()

# ğŸ”§ Menu DiagnÃ³stico do Sistema
from aba_diagnostico import criar_menu_diagnostico
criar_menu_diagnostico(janela, notebook)

# ğŸ—‚ Importando e montando ABAS
from aba_config import montar_aba_config
aba_config = ttk.Frame(notebook)
notebook.add(aba_config, text="âš™ï¸ ConfiguraÃ§Ã£o")
montar_aba_config(aba_config)

from aba_cadastro import montar_aba_cadastro
aba_cadastro = ttk.Frame(notebook)
notebook.add(aba_cadastro, text="ğŸ¶ Cadastro")
montar_aba_cadastro(aba_cadastro)

from aba_consulta import montar_aba_consulta
aba_consulta = ttk.Frame(notebook)
notebook.add(aba_consulta, text="ğŸ” Consulta")
montar_aba_consulta(aba_consulta)

from aba_financeiro import montar_aba_financeiro
aba_financeiro = ttk.Frame(notebook)
notebook.add(aba_financeiro, text="ğŸ’° Financeiro")
montar_aba_financeiro(aba_financeiro)

from aba_relatorio import montar_aba_relatorio
aba_relatorio = ttk.Frame(notebook)
notebook.add(aba_relatorio, text="ğŸ“Š RelatÃ³rios")
montar_aba_relatorio(aba_relatorio)

# ğŸŸ¢ Iniciando a aplicaÃ§Ã£o




# #++++++++++++++++++++++++++++++++++++++++++++

def montar_aba_main(aba):
    # Permitir expansÃ£o
    aba.grid_rowconfigure(0, weight=1)
    aba.grid_columnconfigure(0, weight=1)

    # Canvas + Scrollbar
    canvas = tk.Canvas(aba)
    scrollbar_y = ttk.Scrollbar(aba, orient="vertical", command=canvas.yview)
    canvas.configure(yscrollcommand=scrollbar_y.set)

    canvas.grid(row=0, column=0, sticky="nsew")
    scrollbar_y.grid(row=0, column=1, sticky="ns")

    # Frame rolÃ¡vel
    inner_frame = ttk.Frame(canvas)
    canvas.create_window((0, 0), window=inner_frame, anchor="nw")

    def ajustar_scroll(event):
        canvas.configure(scrollregion=canvas.bbox("all"))
    inner_frame.bind("<Configure>", ajustar_scroll)

    # === A partir daqui, crie widgets dentro do inner_frame ===

    # Exemplo bÃ¡sico
    frame_exemplo = ttk.LabelFrame(inner_frame, text="SeÃ§Ã£o de Exemplo")
    frame_exemplo.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

    ttk.Label(frame_exemplo, text="Alguma informaÃ§Ã£o importante").grid(row=0, column=0, sticky="w")

    # Repita quantos blocos quiser (outros frames, grids, entradas, etc.)

    # Se quiser ativar algo quando o porte mudar
    dc.var_porte.trace_add("write", lambda *args: atualizar_exemplo())

def atualizar_exemplo():
    porte = dc.var_porte.get()
    print(f"Porte selecionado na aba Ã©: {porte}")
#
#



janela.mainloop()










def atualizar_imagem_porte(porte):
    nome_arquivo = dc.imagens_portes.get(porte, "")
    caminho = os.path.join(base_path, nome_arquivo)

    if os.path.exists(caminho):
        img = Image.open(caminho).resize((200, 200))
        img_tk = ImageTk.PhotoImage(img)

        # ğŸ”„ Atribuir como imagem padrÃ£o antes de raÃ§a ser exibida
        dc.label_imagem.img_ref = img_tk  # mantÃ©m referÃªncia genÃ©rica
        dc.label_imagem.config(image=img_tk, text="")
    else:
        dc.label_imagem.config(image="", text="Imagem do porte nÃ£o encontrada")
        dc.label_imagem.img_ref = None























